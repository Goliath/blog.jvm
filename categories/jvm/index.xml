<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>JVM on Bitecode blog</title><link>https://bitecode.blog/categories/jvm/</link><description>Recent content in JVM on Bitecode blog</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Fri, 10 May 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://bitecode.blog/categories/jvm/index.xml" rel="self" type="application/rss+xml"/><item><title>Tweaking the stack for fun and profit</title><link>https://bitecode.blog/2024/05/10/tweaking-stack-for-fun-and-profit/</link><pubDate>Fri, 10 May 2024 00:00:00 +0000</pubDate><guid>https://bitecode.blog/2024/05/10/tweaking-stack-for-fun-and-profit/</guid><description>Stackoverflow we&amp;rsquo;ve all been here&amp;hellip; Most of the time stackoverflow is happening when thread in the JVM application has too long call chain. That results in eating all stack memory by stack frames. In case of stack memory region JVM has safe defaults - 1MB, so usually this scenario occurs when we deal with too deep recursion.
The default can be found by executing:
java -XX:+PrintFlagsFinal -version | grep ThreadStackSize On my machine it give the output:</description></item><item><title>Remote JVM debugging</title><link>https://bitecode.blog/2024/04/23/remote-debugging-on-kubernates/</link><pubDate>Tue, 23 Apr 2024 00:00:00 +0000</pubDate><guid>https://bitecode.blog/2024/04/23/remote-debugging-on-kubernates/</guid><description>Scenario Debugging applications in a local environment is straightforward, but what happens when your application is running in a Kubernetes cluster? Sometimes the best place to debug an issue is the remote instance itself. This article will guide you through the process of remotely debugging your Java applications running in Kubernetes.
Prerequisites In this very short post I assume you have:
a Java application running in a Kubernetes cluster IntelliJ IDEA kubectl command-line tool installed and configured Step 1: Start Your Java Application in Debug Mode First, you need to ensure your Java application is running in debug mode.</description></item><item><title>Introduction to Java ergonomics</title><link>https://bitecode.blog/2024/04/20/java-ergonomics-basics/</link><pubDate>Sat, 20 Apr 2024 00:00:00 +0000</pubDate><guid>https://bitecode.blog/2024/04/20/java-ergonomics-basics/</guid><description>Intro It&amp;rsquo;s not a secret that JVM is an extremly complex execution environment. It has many options that can be set to tune the application execution. What happens if we don&amp;rsquo;t set any of them or we pick only few? In this article I will explain what is Java ergonomics and how it works to supply default JVM options. I will also tell why it&amp;rsquo;s never safe to rely on the defaults.</description></item></channel></rss>