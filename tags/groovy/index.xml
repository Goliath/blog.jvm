<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Groovy on Bitecode blog</title><link>https://bitecode.blog/tags/groovy/</link><description>Recent content in Groovy on Bitecode blog</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Fri, 05 Apr 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://bitecode.blog/tags/groovy/index.xml" rel="self" type="application/rss+xml"/><item><title>Serialization exploits in JVM</title><link>https://bitecode.blog/2024/04/05/jvm-serialization-exploits/</link><pubDate>Fri, 05 Apr 2024 00:00:00 +0000</pubDate><guid>https://bitecode.blog/2024/04/05/jvm-serialization-exploits/</guid><description>&lt;h2 id="intro">Intro&lt;/h2>
&lt;p>The Java Virtual Machine (JVM) provides a mechanism for persisting Java objects, known as serialization.
When introducing, it was a great step forward, as developers stopped reinventing the wheel and writing the same (still complex) boilerplate code.
As we later learned it also opened a pandora box. I will try to describe the problem in the article below.&lt;/p>
&lt;h2 id="problem">Problem&lt;/h2>
&lt;p>This process of serialization involves converting the state of an object into a byte stream, which can then be reverted back into a copy of the object.
That way we can persist any object, store it, then load whenever we want.&lt;/p></description></item><item><title>Between null and positive infinity</title><link>https://bitecode.blog/2016/08/19/groovy-compare-null/</link><pubDate>Fri, 19 Aug 2016 00:00:00 +0000</pubDate><guid>https://bitecode.blog/2016/08/19/groovy-compare-null/</guid><description>&lt;h2 id="problem">Problem&lt;/h2>
&lt;p>I happen to create a construction like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-groovy" data-lang="groovy">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">if&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>object&lt;span style="color:#ff79c6">?.&lt;/span>&lt;span style="color:#50fa7b">value&lt;/span> &lt;span style="color:#ff79c6">&amp;gt;&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span>&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println &lt;span style="color:#f1fa8c">&amp;#34;do something&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span> &lt;span style="color:#ff79c6">else&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println &lt;span style="color:#f1fa8c">&amp;#34;do nothing&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Are you sure what will be printed when object is null?
I must say I wasnâ€™t.&lt;/p>
&lt;p>We got used to negate null in groovy like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-groovy" data-lang="groovy">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">assert&lt;/span> &lt;span style="color:#ff79c6">!&lt;/span>&lt;span style="color:#ff79c6">null&lt;/span> &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#ff79c6">true&lt;/span> 
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>but what about using null with relation operator?&lt;/p>
&lt;h2 id="comparing-null">Comparing null&lt;/h2>
&lt;p>Let us review below code:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-groovy" data-lang="groovy">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">assert&lt;/span> &lt;span style="color:#ff79c6">null&lt;/span> &lt;span style="color:#ff79c6">&amp;lt;&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">assert&lt;/span> &lt;span style="color:#ff79c6">null&lt;/span> &lt;span style="color:#ff79c6">&amp;lt;&lt;/span> Integer&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">MIN_VALUE&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">assert&lt;/span> &lt;span style="color:#ff79c6">null&lt;/span> &lt;span style="color:#ff79c6">&amp;lt;&lt;/span> Double&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">NEGATIVE_INFINITY&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">assert&lt;/span> &lt;span style="color:#ff79c6">null&lt;/span> &lt;span style="color:#ff79c6">&amp;lt;&lt;/span> Integer&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">MAX_VALUE&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">assert&lt;/span> &lt;span style="color:#ff79c6">null&lt;/span> &lt;span style="color:#ff79c6">&amp;lt;&lt;/span> Double&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">POSITIVE_INFINITY&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>In each of these cases, the assertion passes without errors. This behavior might seem counterintuitive at first glance.&lt;/p></description></item></channel></rss>